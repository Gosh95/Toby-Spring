# 3장 템플릿
템플릿은 변경이 거의 일어나지 않는 일정한 패턴을 유지하는 특성을 가진 부분을 따로 떼어내어 효과적으로 활용할 수 있도록 하는 방법이다.

3장에서는 스프링에 적용된 템플릿 기법을 살펴본다.

## 3.1 다시보는 초난감 DAO

### 3.1.1 예외처리 기능을 갖춘 DAO

JDBC 코드를 사용할 때는 반드시 예외처리를 해줘야하는데, DB 커넥션 리소스를 반드시 반환해주는 예외처리를 작성해주어야한다. 이전에 작성한 deleteAll() 메서드를 살펴보자 

```java
public void deleteAll() throws SQLException() {
	Connection c = dataSource.getConnection();
	
	PreparedStatement ps = c.prepareStatement("delete from users");
	ps.executeUpdate();

	ps.close();
	c.close();
}
```

코드가 정상적으로 동작하면 Connection과 PreparedStatement의 리소스가 정상 반환 되겠지만, 중간에 예외가 발생하면 ps.close();와 c.close()가 실행되지 못하고 메소드가 종료된다.

서버는 일정한 수의 DB Connection을 가지고 운영되기 때문에 리소스 사용후 반환 처리가 필수이다.

따라서 JDBC코드에서는 이렇게 예외상황에서도 리소스를 제대로 반환하도록 try/catch/finally를 사용한다.

```java
public void deleteAll() throws SQLException() {
	Connection c = null;
	PreparedStatement ps = null;
	

try {
	c = dataSource.getConnection();
	ps = c.prepareStatement("delete from users");
	ps.executeUpdate();

} catch (SQLException e) {
	throw e;
} finally {
	if(ps != null) {
		try {
			ps.close();
		} catch (SQLException e) {

		}

		if(c != null) {
		try {
			c.close();
		} catch (SQLException e) {

		}
	}
}
}
```

**JDBC 조회 기능의 예외처리**

조회기능은 리소스인 ResultSet이 추가되기때문에 더 복잡해진다. ResultSet 리소스 반환을 위한 try/catch 구문이 추가된다.

## 3.2 변하는 것과 변하지 않는것

### 3.2.1 JDBC try/catch/finally 코드의 문제점

복잡한 try/catch/finally 중첩구문에, 모든 JDBC코드에는 이 try/catch/finally 구문이 반복된다. 이런 반복된 코드는 계속 폭탄이 될 가능 성을 지니고 있다. 수정하기도 어렵고 함부로 건드리거나 삭제하기도 어렵다. 실수로 close() 구문을 작성하지 않으면 DB Connection 자원이 반납되지 않는 오류가 발생할 수도 있다.

이런 코드를 효과적으로 다룰 수 있는 방법은 무엇일까. 반복되는 코드를 분리하는 것이다.

### 3.2.2 분리와 재사용을 위한 디자인 패턴 적용

deleteAll()을 예시로 들어 반복되는 코드를 찾아보자. prepareStatement(~~query~~); 부분을 제외하고 connection을 만들고 자원을 반납하는 부분은 계속 동일하게 반복된다. 이 부분을 재사용하도록 만들자.

**메소드 추출**

메소드로 추출을 하려고했지만 try catch로 감싸고있어 반복되는 부분을 독립시키기가 어렵다. 따라서 반복되지 않는 부분을 역으로 독립시킨다. 

```java
public void deleteAll() throws SQLException() {
	...

	try {
		c = dataSource.getConnection();
		ps = makeStatement(c);
		ps.executeUpdate();

	} catch (SQLException e) {
		...
	}
}

private PreparedStatement makeStatement(Connection c) throws SQLException {
	PreparedStatement ps;
	ps = c.prepareStatement("delete from users");
	return ps;
}
```

하지만 이 방법은 다른 코드에 적용시키기가 어려울 것 같아, 쓸모가 떨어진다.

**템플릿 메소드 패턴의 적용**

템플릿 메소드 패턴을 통해서 문제를 해결해보자. 상속을 통해서 해결하는 방법인데, 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분을 추상 메소드로 정의해서 자식 클래스에서 오버라이드하여 사용하도록 구현한다.

위의 makeStatement 메서드를 추상 메서드로 변경하고, 이 메서드를 포함한 UserDao도 추상 클래스로 변경한다.

이렇게 되면 위의 메소드 추출보다 쓸모있는 코드를 만들 수 있다. 하지만 이 방법에도 단점이 많다.

가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야한다는 점이다.

**전략 패턴의 사용**

개방 패쇄 원칙(OCP)를 잘 지키면서 탬플릿 메소드 패턴보다 유연하고 확장성이 뛰어난것이 전략패턴이다.

전략패턴은 contextMethod()를 통해서 반복되는 부분을 처리하다가, 특정 확장기능은 전략(Strategy) 인터페이스를 통해 외부의 전략 클래스에 위임한다.

```java
public interface StatementStrategy {
	PreparedStatement makePreparedStatement(Connection c) throws SQLException;
}
```

contextMethod가 만들어준 Connection을 받아서 PreparedStatement를 만들어서 돌려준다.

실제 구현체는 하기와 같다.

```java
public class DeleteAllStatement implements StatementStrategy {
	public PreparedStatement makePreparedStatement(Conncetion c) throw

}
```
