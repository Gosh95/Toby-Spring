# 2장 테스트

스프링이 가진 가치의 절반은 객체지향적 설계와 그것을 지원하는 IoC/DI같은 기술이고 나머지 절반은 테스트이다.

2장에서는 테스트란 무엇이고 스프링 과의 관계와 장점, 활용 전략을 살펴본다.

## 2.1 UserDaoTest 다시보기

### 2.1.1 테스트의 유용성

UserDao를 계속 리팩토링 해 나가면서 UserDaoTest가 없었다면 리팩토링 한것이 제대로 돌아가는지 확신 할 수 없었을 것이다. 테스트란 결국 내가 만든 코드를 확신 할 수 있게 해주는 작업이다.

### 2.1.2 UserDaoTest의 특징

```java
public class UserDaoTest {
	public static void main(String[] args) {
		ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
		UserDao dao = context.getBean("userDAo" UserDao.class);
		
		...
	}
}
```

앞서의 UserDaoTest의 특징에는 여러가지가 있지만, 그 중 main() 메소드를 이용한다는 점, 테스트 대상인 UserDao를 직접 호출한다는 점을 살펴보자.

**웹을 통한 DAO 테스트 방법의 문제점**

일반적으로 DAO를 테스트 하는 방법을 생각해보자면, 서비스 계층, MVC, JSP 같은 화면을 전부 만들어서 서버를 띄우고 실제 만들어진 화면에서 데이터를 입력해 가면서 테스트 하는 방법이다. 하지만 이 방법은 테스트의 범위가 너무 넓어서 정작 DAO를 테스트라는 목적을 이루기 어렵다. 

**작은 단위 테스트**

테스트는 가능하면 작은 단위로 쪼개서 집중할 수 있어야한다. 이것을 단위 테스트(Unit Test)라고 한다. 단위의 기준은 정해진 것은 아니고 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위라고 정의할 수 있다.

어떤 개발자는 DB가 사용되면 단위 테스트가 아니라고도 하지만 그렇지만은 않다. DB의 상태에 따라서 테스트가 달라지거나 하는 경우라면 즉 외부의 리소스에 의존하는 테스트라면 단위테스트가 아니라고 보기도 하는 것이다.

단위테스트의 장점 중 하나는 결과를 빨리 확인 받을 수 있다는 것이다. 때문에 빠르고 쉽게 문제의 원인을 찾아서 수정이 가능하다.

**자동수행 테스트 코드**

UserDoaTest의 다른 특징은 테스트할 코드나, 테스트 작업 또한 코드를 통해서 진행된다는 것이다. 앞서 살펴본것처럼 실제 서버를 띄우고 한땀한땀 폼을 입력하는 방식이 아니라 main() 메소드를 이용하여 테스트 전 과정이 자동으로 진행된다. 서버를 띄울 필요도, 브라우저를 열 필요도 없다. 수행 속도도 빠르기 때문에 테스트를 자주 수행해도 부담이 없다.

이렇게 테스트는 코드로 만들어져 자동으로 수행되어야 한다.

**지속적인 개선과 점진적인 개발을 위한 테스트**

테스트 코드가 있었기 때문에 코드를 개선해나가는 작업을 진행 할 수 있다. 테스트를 통해서 무엇이 잘못됐는지 바로 확인 할 수 있기 때문이다. 일단은 동작하는 코드를 만들고 테스트 코드를 함께 만들었기때문에 수정을 거쳐가면서 코드를 개선해 갈 수 있었다.

### 2.1.3 UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
    - 단지 콘솔에 값을 출력해줄 뿐 결과를 사람의 눈으로 확인해야한다.
- 실행 작업의 번거로움
    - main 메소드로 수행하는 것보다 더 편리하고 체계적인 방법이 필요하다.

## 2.2 UserDaoTest 개선

UserDaoTest의 두가지 문제점을 개선해보자

### 2.2.1 테스트 검증의 자동화

테스트 실패는 두가지로 나눌 수 가 있는데, 코드를 실행하는 도중에 에러가 발생하는 경우와 에러발생은 없었지만 실행결과가 원하는 바와 다른 경우가 있다.

위에서는 get()의 결과를 콘솔에 출력하여 사람이 눈으로 확인을 했는데, 이제 자동화를 해서 실행결과가 원하는 바와 같다면 성공했다는 결과를 출력하자.

```java
-- 기존
System.out.println(user.getName());

-- 변경
if(!user.getName().equals(user2.getName())) {
	System.out.println("테스트 실패(name)");
} else {
	System.out.println("조회 테스트 성공");
}
```

이렇게 되면 테스트는 자동화가 되고, 사람은 조회 테스트 성공이라는 문구만 확인 하면 된다.

이렇게 자신의 코드에 대해서 항상 자신감을 가지고 도입한 기술 혹은 수정한 사항이 문제가 없는지 확인 할 수 있는 가장 좋은 방법은 빠르게 실행 가능한 자동화된 테스트를 만들어 두는 것이다.

### 2.2.2 테스트의 효율적인 수행과 결과 관리

main 메서드를 사용하는 대신 자바에서 지원하는 실용적인 테스트 도구를 사용하자. 그중에서도 JUnit은 자바로 단위테스트를 만들때 유용하게 사용할 수 있는 테스트 지원 도구이다.

**JUnit 테스트로 전환**

JUnit은 프레임워크이다. 프레임워크는 애플리케이션의 흐름을 제어한다. 따라서 main() 메서드가 필요 없다.

**테스트 메소드 전환**

기존의 main() 메서드로 만들어진 테스트코드는 main()을 사용하기 때문에 직접 제어권을 갖는다는 의미다. JUnit에 따라 테스트코드를 수정하는데에는 하기의 두가지를 따라야한다.

- 메소드는 public 선언해야한다.
- @Test 라는 애노테이션을 붙여준다.

**검증 코드 전환**

상기의 if / else 문장을 JUnit이 제공하는 assertThat 이라는 Static method를 이용해서 전환한다.

```java
assertThat(user2.getName(), is(user.getName)));
```

JUnit은 예외나 실패가 발생하지 않고 성공적으로 종료되면 테스트가 성공했다고 인식해서 알려주므로 “테스트 성공"이라는 메시지를 굳이 출력 할 필요가 없다.

**JUnit 테스트 실행**

JUnit을 실행하는 코드를 만들어 보자. JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜줘야한다.

 

```java
public static void main(String[] args) {
	JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

테스트가 성공하면 OK가, 실패하면 FAILURES가 출력된다. 또 왜 실패했는지 어디서 실패했는지 결과값이 무엇이 다른지 출력된다.


## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

스프링의 기능을 익히기 위해서는 JUnit을 꼭 사용할 줄 알아야한다. JUnit에 대해서 더 알아본다.

### 2.3.1 JUnit 테스트 실행 방법

가장 좋은 테스트 실행방법은 자바 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

**IDE**

이클립스에서 여러 테스트를 동시에 실행 및 결과를 확인 할 수 있다. 

**빌드 툴**

ANT나 메이븐을 사용하고 있다면 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해서 JUnit 테스트를 사용할 수 있다.

**빌드 스크립트**

여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야할 경우에는 빌드 스크립트를 통해 JUnit을 테스트 하는 방법을 사용하기도 한다.

### 2.3.2 테스트 결과의 일관성

반복적으로 테스트를 실행했을 때 외부(DB 데이터 등) 상태에 상관없이 일관적인 테스트 결과를 얻는 것이 좋은 테스트다.

UserDaoTest에서 예를 들면 한번 addAndGet()을 이용해 사용자를 등록했다면 테스트가 수행된 이후에 해당 값을 지워주면 된다. 이렇게 일관성있는 테스트를 수행하기 위해 UserDao에 새로운 기능을 추가한다.

전체 user를 삭제하는 deleteAll() 기능과 전체 레코드 결과를 알 수있는 getCount() 기능을 추가한다.

이렇게 두가지 기능을 만들었다면 addAndGet() 테스트에 적용한다. 하지만 무턱대고 검증되지도 않은 새로운 두 기능을 함께 현재 실행되는 테스트에 포함시킬 수  는 없기때문에 적절한 검증을 진행 한후 테스트에 포함 시킬 수 있다. 예를들면 getCount()를 검증 할 수 있는데, add() 메서드를 수행한 후에 getCount() 메서드가 정상적으로 동작하는지, deleteAll()을 사용한 후에 getCount()가 정확하게 동작하는지 확인 후 addAndGet() 테스트에 추가 시킬 수 있다. 

**동일한 결과를 보장하는 테스트**

테스트를 실행하면 이전에는 DB 테이블을 삭제해야했지만 이제는 삭제해야하는 작업없이 여러번 수행을 해도 결과가 동일하게 성공한다.

단위테스트는 코드가 바뀌지 않는다면 매번 실행 할 때마다 동일한 테스트 결과를 얻을 수 있어야한다. 또한 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되어야한다.

### 2.3.3 포괄적인 테스트

위에서 getCount()는 다른 메서드 테스트를 할 때 껴서 테스트를 했고 따라서 2가지 케이스에서 밖에 테스트해보지 않았다. 한~두가지 케이스만 검증하고 통과한다고 더이상이 테스트를 해보지 않는 것은 위험하다. 

**getCount() 테스트**

getCount()에 대한 더 꼼꼼한 테스트를 만들기위해 새로운 테스트 메소드를 만들어서 테스트한다. 테스트는 최초 user가 0개에서부터 하나씩 user를 추가해가면서 getCount() 메서드를 검증한다.

```java
@Test
public void count() throws SQLException {
	ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");

	UserDao dao = context.getBean("userDao", UserDao.class);
	User user1 = new User("gyumee", "박성철", "springno1");
	User user2 = new User("leegw700", "이길원", "springno2");
	User user3 = new User("bumjin", "박범진", "springno3");

	dao.deleteAll();
	assertThat(dao.getCount(), is(0));
	
	dao.add(user1);
	assertThat(dao.getCount(), is(1));

	dao.add(user2);
	assertThat(dao.getCount(), is(2));

	dao.add(user3);
	assertThat(dao.getCount(), is(3));
	
}
```

추가로 JUnit은 테스트들의 실행순서를 보장하지 않으므로 순서에 상관없이 독립적인 테스트를 만들어야한다.

**addAndGet() 테스트 보완**

addAndGet()테스트에서 파라미터에 id값을 줬을 때 올바른 user값을 가져오는지 더 정확한 테스트를 할 필요가 있다. User를 여러명 추가해서 id로 불러오는 값이 동일한지 테스트해보자

**get() 예외조건에 대한 테스트**

만약 get() 메소드에 전달된 id값에 해당하는 사용자가 없다면 어떤 결과를 return해야할까? 해당하는 id값을 찾을 수 없다고 예외를 던지는 케이스로 예외조건을 추가해보자.

그런데 이렇게 예외가 발생하는 경우의 테스트는 어떻게 해야할까? 예외가 발생해야 테스트가 성공한 것이고, 발생하지 않으면 테스트가 실패하는 것이다. (지금은 이렇게 사용하지 않지만 아마..) @Test(expected=~Exception.class) 와 같이 적어주면 된다.

하지만 이테스트를 수행하면 실패하게된다. 이제 테스트를 성공시키기 위해 본 코드를 수정해야한다.

**테스트를 성공시키기 위한 코드의 수정**

테스트가 실패하면 원인을 파악에서 코드를 수정하고 이 과정을 반복한다. 코드를 수정해서 테스트를 돌리면, 기존에 만들어둔 테스트도 꼭 함께 돌려야한다. 최종적으로 모든 테스트가 성공하면 새로 추가한 기능과 기존의 기능이 모두 영향을 받지않고 정상적으로 돌아갔음을 알 수 있다.

**포괄적인 테스트**

성공하는 테스트가 아닌 실패하는 테스트도 수행 해 봐야한다. 따라서 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들어야한다. 따라서 테스트를 작성할 때에는 부정적인 케이스를 먼저 만드는 습관을 기르는 것이 좋다.

### 2.3.4 테스트가 이끄는 개발

테스트 코드부터 먼저 만들고 그다음 실제 코드를 만드는 개발 전략이 실제 있다.

**기능설계를 위한 테스트**

테스트 코드는 하나의 기능정의서처럼 보인다. 따라서 추가하고 싶은 사항을 테스트 코드로 표현을 하고 그 테스트 코드를 기반으로 애플리케이션 코드를 만들고 검증한다.

**테스트 주도 개발**

이렇게 테스트 코드를 먼저 만들고 그다음 애플리케이션 코드를 작성하는 방식의 개발을 테스트 주도 개발(TDD)라고한다. “실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다”가 TDD의 기본 원칙이다.

개발자들은 보통 프로덕션코드를 만들고 테스트코드 작성이 점점 미뤄지는데, TDD는 아예 테스트를 먼저 만들고 테스트가 성공하기 위한 프로덕션코드를 만들기 때문에 테스트를 빼먹지 않고 다 만들 수 있다. 또한 테스트와 코드 개발의 싸이클을 빠르게 가져갈 수 있다.

### 2.3.5 테스트 코드 개선

테스트 코드도 리팩토링을 하여 깔끔하고 이해하기 쉬운 코드로 만들 필요가 있다.

몇가지를 살펴보자

@Before는 중복됐던 부분을 반복 수행하도록 도와줌으로써 중복 코드를 없앨 수 있다.

 

```java
private UserDao dao;

@Before
public void setUp() {
	ApplicationContext context = 
		new GenericXmlApplicationContext("applicationContext.xml");
	this.dao = context.getBean("userDao", UserDao.class);
}
```

JUnit이 테스트를 수행하는 방법을 알아보자

1. @Test가 붙은 테스트 메소드를 모두 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장한다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

상기의 상황때문에 @Before 메서드는 모든 테스트메서드 이전에 실행 될 수 있었던 것이다.

한가지 기억해야할 점은 @Test 메서드가 붙은 애들마다 테스트 오브젝트를 한개씩 만든다는 것이다. 왜일까? JUnit이 각 테스트가 서로의 영향을 주지않고 독립적으로 실행됨을 보장해주기 위해서 이다.

**픽스처**

테스트를 수행하는데 필요한 정보나 오브젝트를 픽스처라고한다. 예를들면 테스트 메서드 여러 군데에서 반복적으로 사용되는 dao나 객체들을 픽스처라고 할 수 있다.

이런 픽스처는 @Before에서 만들어 두어 인스턴스 객체로 사용하는 것이 좋을 수 있다.

```java
public class UserDaoTest {

	private User user1;
	private User user2;
	private User user3;
	
	@Before
	public void setUp() {
	
			this.user1 = new User("gyumee", "박성철", "springno1");
			this.user2 = new User("leegw700", "이길원", "springno2");
			this.user3 = new User("bumjin", "박범진", "springno3");
	}
}
```
