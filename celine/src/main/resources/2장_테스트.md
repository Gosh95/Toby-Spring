# 2장 테스트

스프링이 가진 가치의 절반은 객체지향적 설계와 그것을 지원하는 IoC/DI같은 기술이고 나머지 절반은 테스트이다.

2장에서는 테스트란 무엇이고 스프링 과의 관계와 장점, 활용 전략을 살펴본다.

## 2.1 UserDaoTest 다시보기

### 2.1.1 테스트의 유용성

UserDao를 계속 리팩토링 해 나가면서 UserDaoTest가 없었다면 리팩토링 한것이 제대로 돌아가는지 확신 할 수 없었을 것이다. 테스트란 결국 내가 만든 코드를 확신 할 수 있게 해주는 작업이다.

### 2.1.2 UserDaoTest의 특징

```java
public class UserDaoTest {
	public static void main(String[] args) {
		ApplicationContext context = new GenericXmlApplicationContext("applicationContext.xml");
		UserDao dao = context.getBean("userDAo" UserDao.class);
		
		...
	}
}
```

앞서의 UserDaoTest의 특징에는 여러가지가 있지만, 그 중 main() 메소드를 이용한다는 점, 테스트 대상인 UserDao를 직접 호출한다는 점을 살펴보자.

**웹을 통한 DAO 테스트 방법의 문제점**

일반적으로 DAO를 테스트 하는 방법을 생각해보자면, 서비스 계층, MVC, JSP 같은 화면을 전부 만들어서 서버를 띄우고 실제 만들어진 화면에서 데이터를 입력해 가면서 테스트 하는 방법이다. 하지만 이 방법은 테스트의 범위가 너무 넓어서 정작 DAO를 테스트라는 목적을 이루기 어렵다. 

**작은 단위 테스트**

테스트는 가능하면 작은 단위로 쪼개서 집중할 수 있어야한다. 이것을 단위 테스트(Unit Test)라고 한다. 단위의 기준은 정해진 것은 아니고 하나의 관심에 집중해서 효율적으로 테스트할 만한 범위라고 정의할 수 있다.

어떤 개발자는 DB가 사용되면 단위 테스트가 아니라고도 하지만 그렇지만은 않다. DB의 상태에 따라서 테스트가 달라지거나 하는 경우라면 즉 외부의 리소스에 의존하는 테스트라면 단위테스트가 아니라고 보기도 하는 것이다.

단위테스트의 장점 중 하나는 결과를 빨리 확인 받을 수 있다는 것이다. 때문에 빠르고 쉽게 문제의 원인을 찾아서 수정이 가능하다.

**자동수행 테스트 코드**

UserDoaTest의 다른 특징은 테스트할 코드나, 테스트 작업 또한 코드를 통해서 진행된다는 것이다. 앞서 살펴본것처럼 실제 서버를 띄우고 한땀한땀 폼을 입력하는 방식이 아니라 main() 메소드를 이용하여 테스트 전 과정이 자동으로 진행된다. 서버를 띄울 필요도, 브라우저를 열 필요도 없다. 수행 속도도 빠르기 때문에 테스트를 자주 수행해도 부담이 없다.

이렇게 테스트는 코드로 만들어져 자동으로 수행되어야 한다.

**지속적인 개선과 점진적인 개발을 위한 테스트**

테스트 코드가 있었기 때문에 코드를 개선해나가는 작업을 진행 할 수 있다. 테스트를 통해서 무엇이 잘못됐는지 바로 확인 할 수 있기 때문이다. 일단은 동작하는 코드를 만들고 테스트 코드를 함께 만들었기때문에 수정을 거쳐가면서 코드를 개선해 갈 수 있었다.

### 2.1.3 UserDaoTest의 문제점

- 수동 확인 작업의 번거로움
    - 단지 콘솔에 값을 출력해줄 뿐 결과를 사람의 눈으로 확인해야한다.
- 실행 작업의 번거로움
    - main 메소드로 수행하는 것보다 더 편리하고 체계적인 방법이 필요하다.

## 2.2 UserDaoTest 개선

UserDaoTest의 두가지 문제점을 개선해보자

### 2.2.1 테스트 검증의 자동화

테스트 실패는 두가지로 나눌 수 가 있는데, 코드를 실행하는 도중에 에러가 발생하는 경우와 에러발생은 없었지만 실행결과가 원하는 바와 다른 경우가 있다.

위에서는 get()의 결과를 콘솔에 출력하여 사람이 눈으로 확인을 했는데, 이제 자동화를 해서 실행결과가 원하는 바와 같다면 성공했다는 결과를 출력하자.

```java
-- 기존
System.out.println(user.getName());

-- 변경
if(!user.getName().equals(user2.getName())) {
	System.out.println("테스트 실패(name)");
} else {
	System.out.println("조회 테스트 성공");
}
```

이렇게 되면 테스트는 자동화가 되고, 사람은 조회 테스트 성공이라는 문구만 확인 하면 된다.

이렇게 자신의 코드에 대해서 항상 자신감을 가지고 도입한 기술 혹은 수정한 사항이 문제가 없는지 확인 할 수 있는 가장 좋은 방법은 빠르게 실행 가능한 자동화된 테스트를 만들어 두는 것이다.

### 2.2.2 테스트의 효율적인 수행과 결과 관리

main 메서드를 사용하는 대신 자바에서 지원하는 실용적인 테스트 도구를 사용하자. 그중에서도 JUnit은 자바로 단위테스트를 만들때 유용하게 사용할 수 있는 테스트 지원 도구이다.

**JUnit 테스트로 전환**

JUnit은 프레임워크이다. 프레임워크는 애플리케이션의 흐름을 제어한다. 따라서 main() 메서드가 필요 없다.

**테스트 메소드 전환**

기존의 main() 메서드로 만들어진 테스트코드는 main()을 사용하기 때문에 직접 제어권을 갖는다는 의미다. JUnit에 따라 테스트코드를 수정하는데에는 하기의 두가지를 따라야한다.

- 메소드는 public 선언해야한다.
- @Test 라는 애노테이션을 붙여준다.

**검증 코드 전환**

상기의 if / else 문장을 JUnit이 제공하는 assertThat 이라는 Static method를 이용해서 전환한다.

```java
assertThat(user2.getName(), is(user.getName)));
```

JUnit은 예외나 실패가 발생하지 않고 성공적으로 종료되면 테스트가 성공했다고 인식해서 알려주므로 “테스트 성공"이라는 메시지를 굳이 출력 할 필요가 없다.

**JUnit 테스트 실행**

JUnit을 실행하는 코드를 만들어 보자. JUnit 프레임워크도 자바 코드로 만들어진 프로그램이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜줘야한다.

 

```java
public static void main(String[] args) {
	JUnitCore.main("springbook.user.dao.UserDaoTest");
}
```

테스트가 성공하면 OK가, 실패하면 FAILURES가 출력된다. 또 왜 실패했는지 어디서 실패했는지 결과값이 무엇이 다른지 출력된다.
