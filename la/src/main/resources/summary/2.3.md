# 토비의 스프링 7일차

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

### 2.3.1 JUnit 테스트 실행 방법

###  IDE

JUnit 테스트를 실행하는 가장 좋은 방법은 IDE에 내장된 JUnit 테스트 지원 도구를 사용하는 것이다.

IDE의 도움을 받으면 JUnitCore를 이용할 때처럼 main() 메소드를 만들지 않아도 된다. 또한 매우 직관적이며 소스와 긴밀하게 연동돼서 결과를 볼 수 있다. 때문에 IDE의 지원을 받는 것이 가장 편리하다.

### 빌드 툴

메이븐, 그래들과 같은 빌드 툴을 사용하고 있다면, 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 테스트를 실행할 수 있다. 테스트 실행 결과는 옵션에 따라서 HTML이나 텍스트 파일의 형태로 보기 좋게 만들어진다.

### 2.3.2 테스트 결과의 일관성

지금까지 테스트를 실행하면서 가장 불편했던 일은, 매번 DB의 USER 테이블 데이터를 모두 삭제해줘야 할 때였다. 깜빡 잊고 테스트를 그냥 실행한다면 중복과 같은 이슈로 에러가 발생할 것이다.

여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한다는 점이다. `반복적으로 테스트를 실행했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 볼 수 없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.`

UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있다는 점이다. 가장 좋은 해결책은 테스트를 마치고 나면 테스트가 등록한 정보를 삭제해서, 테스트 수행 전의 상태로 되돌리는 것이다.

### deleteAll()의 getCount() 추가

테스트 후 데이터를 제거할 deleteAll() 메서드와 제대로 삭제됬는지 확인하기 위한 getCount() 메서드를 만들어준다.

```java
  public void deleteAll() throws SQLException {
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("delete from users");
    ps.executeUpdate();

    ps.close();
    c.close();
  }
  
  public int getCount() throws SQLException{
    Connection c = dataSource.getConnection();

    PreparedStatement ps = c.prepareStatement("select count(*) from users");

    ResultSet rs = ps.executeQuery();
    rs.next();
    int count = rs.getInt(1);

    rs.close();
    ps.close();
    c.close();
    
    return count;
  }
```

### 동일한 결과를 보장하는 테스트

이제 테스트를 반복해서 여러 번 실행해도 계속 성공할 것이다.

`단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다.` DB에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하는 것은 물론이고, 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

### 2.3.3 포괄적인 테스트

`테스트를 안 만드는 것도 위험한 일이지만, 성의 없이 테스트를 만드는 바람에 문제가 있는 코드인데도 테스트가 성공하게 만드는 건 더 위험하다.` 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.

JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다. 테스트의 결과가 테스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.

개발자가 테스트를 직접 만들 때 자주 하는 실수가 하나 있다. 바로 성공하는 테스트만 골라서 만드는 것이다.

하지만 개발자도 조금만 신경을 쓰면 자신이 만든 코드에서 발생할 수 있는 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들 수 있다. 스프링의 창시자인 로드 존선은 '항상 네거티브 테스트를 먼저 만들라'는 조언을 했다.

그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

### 2.3.4 테스트가 이끄는 개발

테스트할 코드도 안 만들어놓고 테스트 코드부터 만드는 것은 좀 이상하다고 생각할지 모른다. 그런데 이런 순서를 따라서 개발을 진행하는 구체적인 개발 전략이 실제로 존재한다.

### 테스트 주도 개발

만들고자 하는 기능의 내용을 담고 있으면서 만들어진 코드를 검증도 해줄 수 있도록 테스트 코드를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이 있다. 이를 `테스트 주도 개발(Test Driven Development)` 라고 한다. 또는 테스트를 코드보다 먼저 작성한다고 해서 `테스트 우선 개발(Test First Development)` 이라고도 한다. "실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다."는 것이 TDD의 기본 원칙이다. `이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스트로 검증된 것이라고 볼 수 있다.`

TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다. 또한 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다. 그 덕분에 코드에 대한 피드백을 매우 빠르게 받을 수 있게 된다. 또, 매번 테스트가 성공하는 것을 보면서 작성한 코드에 대한 확신을 가질 수 있어, 다음 단계로 넘어갈 수 있다.

TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 한 짧게 가져가도록 권장한다.

TDD의 장점 중 하나는 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다는 점이다. 개발한 코드의 오류는 빨리 발견할수록 좋다. 빨리 발견된 오류는 쉽게 대응이 가능하기 때문이다. 테스트 없이 오랜 시간 동안 코드를 만들고 나서 테스트를 하면, 오류가 발생했을 때 원인을 찾기가 쉽지 않다.

테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 그러려면 테스트 없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다.

혹시 테스트를 만들고 자주 실행하면 개발이 지연되지 않을까 염려할지도 모른다. 하지만 테스트는 애플리케이션 코드보다 상대적으로 작성하기 쉬운데다 각 테스트가 독립적이기 때문에, 코드의 양에 비해 작성하는 시간은 얼마 걸리지 않는다. 게다가 테스트 덕분에 오류를 빨리 잡아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진다.

### 2.3.5 테스트 코드 개선

애플리케이션 코드만이 리팩토링의 대상은 아니다. 필요하다면 테스트 코드도 언제든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 코드로 만들 필요가 있다.

JUnit이 하나의 테스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.
1. 테스트 클래스에 @Test가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모드 찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.

실제로는 이보다 더 복잡한데, 간단히 정리하면 JUnit 테스트는 위의 7단계를 거쳐서 진행된다고 볼 수 있다.

또 한 가지 꼭 기억해야 할 사항은 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다는 점이다. 한번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다. 테스트 클래스가 @Test 테스트 메소드를 두 개 갖고 있다면, 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만들 것이다. 

그런데, 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 것일까? JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다.

### 픽스처

`테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처라고 한다.` 일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두면 편리하다. 

