## 4.1 사라진 SQLException

### 4.1.1 초난감 예외처리

개발자들의 코드에서 종종 발견되는 초난감 예외처리의 예를 살펴보자.

### 예외 블랙홀

```java
  try {
  
  } catch (SQLException ex) {
    //예외를 잡고는 아무것도 하지 않음.
  }
```

예외가 발생하면 그것을 catch 블록을 써서 잡아놓고 아무것도 하지 않는 것은 예외가 발생하는 것보다 훨씬 나쁜 일이다. 왜냐하면 예외를 무시해 버린다면 디버깅이 힘들고 예상치 못한 더 큰 문제로 이어질 수 있기 때문이다.

```java
  try {
  
  } catch (SQLException ex) {
    //ex1) System.out.println(ex);
    //ex2) ex.printStackTrace();
  }
```

이와 같이 예외를 단순히 콘솔에 출력하는 것도 문제가 된다. 이렇게 콘솔에 출력한다면 모니터링을 24시간 하지 않는 이상 다른 로그 메시지에 금방 묻혀버리게 될 것이다. 

예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다. `모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다.`

### 무의미하고 무책임한 throws

```java
    public void method1() throws Exception {
      
    }
    
    public void method() throws Exception {
        method1();
    }
```

이런 무책임한 throws 선언에는 심각한 문제점이 있다.

정말로 실행 중 예외적인 상황이 발생할 수 있다는 것인지, 무의식적으로 복사해서 붙여넣은 것인지 알 수 없다. `결과적으로 적절한 처리를 통해 복구될 수 있는 예외조차 흘려버리게 된다.`

### 4.1.2 예외의 종류와 특징

자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

- **error**

    java.lang.Error 클래스의 서브클래스들이다. 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. `그래서 주로 JVM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안 된다.` OutOfMemory, ThreadDeath 와 같은 에러들은 catch 블록으로 잡아봤자 아무런 대응 방법이 없기 때문이다.

- **Exception과 체크 예외**
 
    java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외 상황이 발생했을 경우에 사용된다.

    Exception 클래스는 다시 체크, 언체크로 구분된다. 전자는 Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들이고, 후자는 RuntimeException을 상속한 클래스들을 말한다.

    체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다.

- **RuntimeException과 언체크/런타임 예외**
    
    java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외 또는 런타임 예외라고 불린다. 에러와 마찬가지로 catch 문으로 잡거나 throws로 선언하지 않아도 된다.

    런타임 예외는 주로 프로그램의 오류가 있을 때 발생호도록 의도된 것들이다. 대표적으로 NullPointerException, IllegalArgumentException 등이 있다. 이런 예외는 미리 조건을 체크하도록 주의 깊게 만든다면 피할 수 있다.

최근에 새로 등장하는 자바 표준 스펙의 API들은 예상 가능한 예외상황을 다루는 예외를 체크 예외로 만들지 않는 경향이 있다.

### 4.1.3 예외처리 방법

### 예외 복구

첫 번째 예외처리 방법은 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것이다.

예를 들어 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없어 IOException이 발생했을 때 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황을 해결할 수 있다. 

단, IOException 에러 메시지가 사용자에게 그냥 던져지는 것은 예외 복구라고 볼 수 없다.

`예외처리 코드를 강제하는 체크 예외들은 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용한다.`

### 예외처리 회피

두 번째 방법은 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다.

JdbcContext, JdbcTemplate 가 사용하는 콜백 오브젝트는 ResultSet, PreparedStatement 등을 이용해서 작업하다 발생하는 SQLException을 자신이 처리하지 않고 템플릿으로 던져버린다. 콜백 오브젝트의 메소드는 모두 throws SQLException이 붙어 있다. `SQLException을 처리하는 일은 콜백 오브젝트의 역할이 아니라고 보기 때문이다.` 

하지만 콜백과 템플릿처럼 긴밀하게 역할을 분담하고 있는 관계가 아니라면 자신의 코드에서 발생하는 예외를 그냥 던져버리는 건 무책임한 책임회피일 수 있다.
 
`예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.` 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다.

### 예외 전환

마지막으로 예외를 처리하는 방법은 예외 전환을 하는 것이다. 예외 회피와 비슷하게 예외를 메소드 밖으로 던지는 것이다. 하지만 예외 회피와 달리, 발생한 예외를 그대로 넘기는 게 아니라 `적절한 예외로 전환해서 던진다는 특징이 있다.`

예외 전환은 보통 두 가지 목적으로 사용된다.

`첫째는 내부에서 발생한 예외에 대해 의미를 제대로 부여해주지 못한 경우, 의미를 분명하게 해줄 수 있는 다른 예외로 바꿔주기 위해서다.`

예를 들어 새로운 사용자를 등록하려고 시도했을 때 아이디가 같은 사용자가 있다면 JDBC API는 SQLException을 발생시킨다. 이 경우 해당 API를 사용하는 서비스 계층에서는 왜 SQLException이 발생했는지 알 수 없다. 이럴 땐 해당 정보를 해석해서 DuplicateUserIdException 같은 예외로 바꿔서 던져주는 게 좋다. `이렇게 전환을 할 때는 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋다.`

```java
  catch (SQLException ex) {
    // 중첩 예외1 throw new DuplicatedUserIdException(ex);
    // 중첩 예외2 throw new DuplicatedUserIdException().initCause(ex);
  }
```

두 번째 전환 방법은 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것이다. 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다. `주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.`


```java
// EJB 컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비지니스 로직으로 볼 때 의미있는 예외이거나 복구 가능한 예외가 아니다.
  try{
    // hello world
  } catch (NamingException ex) {
    throw new EJBException(ex);
  } catch (SQLException ex) {
    throw new EJBException(ex);
  } catch (RemoteException ex) {
    throw new EJBException(ex);
  }
```

`일반적으로 체크 예외를 계속 throws를 사용해 넘기는 건 무의미하다.` 메소드 선언은 지저분해지고 아무런 장점이 없다. `어차피 복구하지 못할 예외라면 빨리 런타임 예외로 전환하여 던져버려서 로깅 또는 관리자에게 알림, 사용자에게는 메시지를 전달하는 방법으로 처리하는 게 바람직하다.`   

### 4.1.4 예외처리 전략

### 런타임 예외의 보편화

일반적으로 체크 예외가 일반적인 예외를 다루고, 언체크 예외는 시스템 장애나 프로그램사으이 오류에 사용된다.  문제는 체크 예외는 catch 블록이나 throws 선언을 강제하고 있다는 점이다. 이렇게 예외처리를 강제하는 것은 실수를 방지하기 위한 배려라고 볼 수도 있지만, 실제로는 예외를 다루고 싶지 않게 만드는 원인이 되기도 한다.

자바가 처음 만들어질 때 많이 사용되던 애프릿, AWT, 스윙을 사용한 독립형 애플리케이션은 통제가 불가능한 시스템 예외일 지라도 작업이 중단되지 않게 복구를 해줘야 했다.

하지만 자바 엔터프라이즈 서버환경은 다르다. `수많은 요청 각각이 독립적인 작업으로 취급되기 때문에 예외가 발생한 해당 작업만 중단시키면 그만이다.`

자바의 환경이 서버로 이동하면서 체크 예외를 사용하기 보다 빨리 런타임 예외로 전환해서 던지는 편이 효율적이다.

### add() 메소드의 예외처리

```java
  try {
    // user 정보를 추가하는 코드
  } catch (SQLException ex) {
    if (ex.getErrorCode() == MySqlErrorNumbers.ER_DUP_ENTRY) { // 오 이거 몰랐음
      throw new DuplicatedUserIdException(ex);  
    }
  }
```

이렇게 런타임 예외로 전환하여 불필요한 throws 선언을 할 필요가 없어졌다.

물론 장점만 있는 것은 아니다. 컴파일러가 예외처리를 강제하지 않기 때문에 예외상황을 충분히 고려하지 않을 수도 있기 때문이다. 이러한 경우에는 API 문서나 레퍼런스 문서 등을 통해, 예외 상황에 대해서 설명을 해주는 것이 좋다.

### 애플리케이션 예외

시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외도 있다. 이런 예외들을 일반적으로 애플리케이션 예외라고 한다.

이러한 예외를 처리하는 방법에는 두 가지 있다.

첫 번째 방법은 예외가 발생했을 때 0 또는 -1과 같은 특별한 코드 값을 리턴하는 것이다. 이 메소드를 호출한 쪽은 해당 리턴 값을 확인하여 예외상황이 있는지 확인한다.

두 번째 방법은 비지니스적인 의미를 띈 예외를 던지도록 만드는 것이다. 예를 들어 잔고가 부족한 경우에는 InsufficientBalanceException 등을 던진다.

이 때 사용하는 예외는 의도적으로 체크 예외로 만든다. 그래서 개발자가 잊지 않고 예외를 처리하도록 강제하는 것이 좋다.

### 4.1.5 SQLException은 어떻게 됐나?

우선 SQLException은 복구가 가능한 예외인가를 생각해 보자. 대부분의 SQLException은 코드 레벨에서는 복구할 방법이 없다. 

시스템의 예외 역시 당연히 애플리케이션 레벨에서 복구할 방법이 없다.

이러한 상황에서는 가능한 빨리 런타임 예외로 전환하여 사용자 또는 개발자에게 알려주는 것이 좋다.

스프링의 JdbcTemplate은 이 예외처리 전략을 따르고 있다. JdbcTemplate 템플릿과 콜백 안에서 발생하는 모든 SQLException을 런타임 예외인 DataAccessException으로 포장해서 던져준다.